<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/ui/edit_observation/EditObservationActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/ui/edit_observation/EditObservationActivity.java" />
              <option name="originalContent" value="package com.example.hikenativeapp.ui.edit_observation;&#10;&#10;import android.Manifest;&#10;import android.app.DatePickerDialog;&#10;import android.app.TimePickerDialog;&#10;import android.content.Intent;&#10;import android.content.pm.PackageManager;&#10;import android.net.Uri;&#10;import android.os.Build;&#10;import android.os.Bundle;&#10;import android.os.Environment;&#10;import android.provider.MediaStore;&#10;import android.view.View;&#10;import android.widget.Button;&#10;import android.widget.EditText;&#10;import android.widget.ImageView;&#10;import android.widget.ProgressBar;&#10;import android.widget.Toast;&#10;&#10;import androidx.activity.result.ActivityResultLauncher;&#10;import androidx.activity.result.contract.ActivityResultContracts;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.appcompat.widget.Toolbar;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.core.content.FileProvider;&#10;import androidx.lifecycle.ViewModelProvider;&#10;&#10;import com.bumptech.glide.Glide;&#10;import com.example.hikenativeapp.R;&#10;import com.example.hikenativeapp.data.local.entity.Observation;&#10;import com.example.hikenativeapp.data.repository.ObservationRepository;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;import java.util.Locale;&#10;&#10;public class EditObservationActivity extends AppCompatActivity {&#10;&#10;    private EditText etObservationText, etObservationTime, etComments;&#10;    private Button btnSave, btnCancel, btnSelectTime, btnTakePhoto, btnRemovePhoto;&#10;    private ImageView ivObservationPhoto;&#10;    private Toolbar toolbar;&#10;    private ProgressBar progressBar;&#10;&#10;    private EditObservationViewModel viewModel;&#10;    private ObservationRepository repository;&#10;    private int observationId;&#10;    private int hikeId;&#10;    private String hikeName;&#10;    private Observation currentObservation;&#10;    private Calendar selectedDateTime;&#10;    private boolean viewMode = false;&#10;    private String currentPhotoPath;&#10;&#10;    // Activity Result Launchers&#10;    private ActivityResultLauncher&lt;Intent&gt; takePictureLauncher;&#10;    private ActivityResultLauncher&lt;String[]&gt; requestPermissionLauncher;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_edit_observation);&#10;&#10;        // Get data from intent&#10;        observationId = getIntent().getIntExtra(&quot;OBSERVATION_ID&quot;, -1);&#10;        hikeId = getIntent().getIntExtra(&quot;HIKE_ID&quot;, -1);&#10;        hikeName = getIntent().getStringExtra(&quot;HIKE_NAME&quot;);&#10;        viewMode = getIntent().getBooleanExtra(&quot;VIEW_MODE&quot;, false);&#10;&#10;        if (observationId == -1 || hikeId == -1) {&#10;            Toast.makeText(this, &quot;Invalid observation&quot;, Toast.LENGTH_SHORT).show();&#10;            finish();&#10;            return;&#10;        }&#10;&#10;        initializeActivityResultLaunchers();&#10;        initializeComponents();&#10;        setupViewModel();&#10;        setupListeners();&#10;        observeViewModel();&#10;&#10;        // Load observation through ViewModel&#10;        viewModel.loadObservation(observationId);&#10;    }&#10;&#10;    private void initializeActivityResultLaunchers() {&#10;        // Camera launcher&#10;        takePictureLauncher = registerForActivityResult(&#10;            new ActivityResultContracts.StartActivityForResult(),&#10;            result -&gt; {&#10;                if (result.getResultCode() == RESULT_OK) {&#10;                    // Photo saved to currentPhotoPath&#10;                    displayPhoto();&#10;                }&#10;            }&#10;        );&#10;&#10;        // Permission launcher&#10;        requestPermissionLauncher = registerForActivityResult(&#10;            new ActivityResultContracts.RequestMultiplePermissions(),&#10;            permissions -&gt; {&#10;                boolean allGranted = true;&#10;                for (Boolean granted : permissions.values()) {&#10;                    if (!granted) {&#10;                        allGranted = false;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (allGranted) {&#10;                    dispatchTakePictureIntent();&#10;                } else {&#10;                    Toast.makeText(this, &quot;Camera and storage permissions are required&quot;, Toast.LENGTH_SHORT).show();&#10;                }&#10;            }&#10;        );&#10;    }&#10;&#10;    private void initializeComponents() {&#10;        toolbar = findViewById(R.id.toolbar);&#10;        etObservationText = findViewById(R.id.et_observation_text);&#10;        etObservationTime = findViewById(R.id.et_observation_time);&#10;        etComments = findViewById(R.id.et_comments);&#10;        btnSave = findViewById(R.id.btn_save);&#10;        btnCancel = findViewById(R.id.btn_cancel);&#10;        btnSelectTime = findViewById(R.id.btn_select_time);&#10;        btnTakePhoto = findViewById(R.id.btn_take_photo);&#10;        btnRemovePhoto = findViewById(R.id.btn_remove_photo);&#10;        ivObservationPhoto = findViewById(R.id.iv_observation_photo);&#10;        progressBar = findViewById(R.id.progress_bar);&#10;&#10;        repository = new ObservationRepository(this);&#10;        selectedDateTime = Calendar.getInstance();&#10;&#10;        // Setup Toolbar&#10;        setSupportActionBar(toolbar);&#10;        if (getSupportActionBar() != null) {&#10;            getSupportActionBar().setTitle(viewMode ? &quot;View Observation&quot; : &quot;Edit Observation&quot;);&#10;            getSupportActionBar().setDisplayHomeAsUpEnabled(true);&#10;        }&#10;&#10;        // If view mode, disable all inputs&#10;        if (viewMode) {&#10;            etObservationText.setEnabled(false);&#10;            etObservationTime.setEnabled(false);&#10;            etComments.setEnabled(false);&#10;            btnSelectTime.setEnabled(false);&#10;            btnTakePhoto.setEnabled(false);&#10;            btnSave.setVisibility(View.GONE);&#10;        }&#10;    }&#10;&#10;    private void setupViewModel() {&#10;        viewModel = new ViewModelProvider(this).get(EditObservationViewModel.class);&#10;        viewModel.setRepository(repository);&#10;    }&#10;&#10;    private void observeViewModel() {&#10;        // Observe observation data&#10;        viewModel.observation.observe(this, observation -&gt; {&#10;            if (observation != null) {&#10;                currentObservation = observation;&#10;                displayObservation();&#10;            }&#10;        });&#10;&#10;        // Observe update success&#10;        viewModel.updateSuccess.observe(this, success -&gt; {&#10;            if (success != null &amp;&amp; success) {&#10;                Toast.makeText(this, &quot;Observation updated successfully&quot;, Toast.LENGTH_SHORT).show();&#10;                finish();&#10;            }&#10;        });&#10;&#10;        // Observe error messages&#10;        viewModel.errorMessage.observe(this, error -&gt; {&#10;            if (error != null &amp;&amp; !error.isEmpty()) {&#10;                Toast.makeText(this, error, Toast.LENGTH_SHORT).show();&#10;            }&#10;        });&#10;&#10;        // Observe loading state&#10;        viewModel.isLoading.observe(this, isLoading -&gt; {&#10;            if (isLoading != null) {&#10;                if (isLoading) {&#10;                    progressBar.setVisibility(View.VISIBLE);&#10;                    btnSave.setEnabled(false);&#10;                } else {&#10;                    progressBar.setVisibility(View.GONE);&#10;                    btnSave.setEnabled(true);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private void setupListeners() {&#10;        btnSelectTime.setOnClickListener(v -&gt; showDateTimePicker());&#10;&#10;        btnSave.setOnClickListener(v -&gt; updateObservation());&#10;&#10;        btnCancel.setOnClickListener(v -&gt; finish());&#10;&#10;        toolbar.setNavigationOnClickListener(v -&gt; finish());&#10;&#10;        btnTakePhoto.setOnClickListener(v -&gt; checkCameraAndStoragePermissions());&#10;&#10;        btnRemovePhoto.setOnClickListener(v -&gt; removePhoto());&#10;    }&#10;&#10;    private void displayObservation() {&#10;        etObservationText.setText(currentObservation.getObservationText());&#10;        etObservationTime.setText(currentObservation.getObservationTime());&#10;        etComments.setText(currentObservation.getComments());&#10;&#10;        // Display existing photo if available&#10;        currentPhotoPath = currentObservation.getPhotoPath();&#10;        if (currentPhotoPath != null &amp;&amp; !currentPhotoPath.isEmpty()) {&#10;            displayPhoto();&#10;        }&#10;    }&#10;&#10;    private void showDateTimePicker() {&#10;        // Show date picker first&#10;        DatePickerDialog datePickerDialog = new DatePickerDialog(&#10;            this,&#10;            (view, year, month, dayOfMonth) -&gt; {&#10;                selectedDateTime.set(Calendar.YEAR, year);&#10;                selectedDateTime.set(Calendar.MONTH, month);&#10;                selectedDateTime.set(Calendar.DAY_OF_MONTH, dayOfMonth);&#10;&#10;                // Then show time picker&#10;                showTimePicker();&#10;            },&#10;            selectedDateTime.get(Calendar.YEAR),&#10;            selectedDateTime.get(Calendar.MONTH),&#10;            selectedDateTime.get(Calendar.DAY_OF_MONTH)&#10;        );&#10;        datePickerDialog.show();&#10;    }&#10;&#10;    private void showTimePicker() {&#10;        TimePickerDialog timePickerDialog = new TimePickerDialog(&#10;            this,&#10;            (view, hourOfDay, minute) -&gt; {&#10;                selectedDateTime.set(Calendar.HOUR_OF_DAY, hourOfDay);&#10;                selectedDateTime.set(Calendar.MINUTE, minute);&#10;                updateTimeDisplay();&#10;            },&#10;            selectedDateTime.get(Calendar.HOUR_OF_DAY),&#10;            selectedDateTime.get(Calendar.MINUTE),&#10;            true&#10;        );&#10;        timePickerDialog.show();&#10;    }&#10;&#10;    private void updateTimeDisplay() {&#10;        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;, Locale.getDefault());&#10;        etObservationTime.setText(sdf.format(selectedDateTime.getTime()));&#10;    }&#10;&#10;    private void checkCameraAndStoragePermissions() {&#10;        String[] permissions;&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            permissions = new String[]{&#10;                Manifest.permission.CAMERA,&#10;                Manifest.permission.READ_MEDIA_IMAGES&#10;            };&#10;        } else {&#10;            permissions = new String[]{&#10;                Manifest.permission.CAMERA,&#10;                Manifest.permission.READ_EXTERNAL_STORAGE,&#10;                Manifest.permission.WRITE_EXTERNAL_STORAGE&#10;            };&#10;        }&#10;&#10;        boolean allPermissionsGranted = true;&#10;        for (String permission : permissions) {&#10;            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {&#10;                allPermissionsGranted = false;&#10;                break;&#10;            }&#10;        }&#10;&#10;        if (allPermissionsGranted) {&#10;            dispatchTakePictureIntent();&#10;        } else {&#10;            requestPermissionLauncher.launch(permissions);&#10;        }&#10;    }&#10;&#10;    private void dispatchTakePictureIntent() {&#10;        Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);&#10;&#10;        if (takePictureIntent.resolveActivity(getPackageManager()) != null) {&#10;            File photoFile = null;&#10;            try {&#10;                photoFile = createImageFile();&#10;            } catch (IOException ex) {&#10;                Toast.makeText(this, &quot;Error creating image file&quot;, Toast.LENGTH_SHORT).show();&#10;                return;&#10;            }&#10;&#10;            if (photoFile != null) {&#10;                Uri photoURI = FileProvider.getUriForFile(&#10;                    this,&#10;                    getPackageName() + &quot;.fileprovider&quot;,&#10;                    photoFile&#10;                );&#10;                takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);&#10;                takePictureLauncher.launch(takePictureIntent);&#10;            }&#10;        } else {&#10;            Toast.makeText(this, &quot;No camera app found&quot;, Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;&#10;    private File createImageFile() throws IOException {&#10;        String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;, Locale.getDefault()).format(new Date());&#10;        String imageFileName = &quot;OBSERVATION_&quot; + timeStamp + &quot;_&quot;;&#10;        File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);&#10;&#10;        File image = File.createTempFile(&#10;            imageFileName,&#10;            &quot;.jpg&quot;,&#10;            storageDir&#10;        );&#10;&#10;        currentPhotoPath = image.getAbsolutePath();&#10;        return image;&#10;    }&#10;&#10;    private void displayPhoto() {&#10;        if (currentPhotoPath != null &amp;&amp; !currentPhotoPath.isEmpty()) {&#10;            File imgFile = new File(currentPhotoPath);&#10;            if (imgFile.exists()) {&#10;                Glide.with(this)&#10;                    .load(imgFile)&#10;                    .centerCrop()&#10;                    .into(ivObservationPhoto);&#10;&#10;                ivObservationPhoto.setVisibility(View.VISIBLE);&#10;                btnRemovePhoto.setVisibility(viewMode ? View.GONE : View.VISIBLE);&#10;                if (!viewMode) {&#10;                    btnTakePhoto.setText(&quot;Retake Photo&quot;);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void removePhoto() {&#10;        // Delete old photo file if it exists&#10;        if (currentPhotoPath != null &amp;&amp; !currentPhotoPath.isEmpty()) {&#10;            File oldPhoto = new File(currentPhotoPath);&#10;            if (oldPhoto.exists()) {&#10;                oldPhoto.delete();&#10;            }&#10;        }&#10;&#10;        currentPhotoPath = null;&#10;        ivObservationPhoto.setVisibility(View.GONE);&#10;        btnRemovePhoto.setVisibility(View.GONE);&#10;        btnTakePhoto.setText(&quot;Take Photo&quot;);&#10;&#10;        // Clear the ImageView&#10;        Glide.with(this).clear(ivObservationPhoto);&#10;    }&#10;&#10;    private void updateObservation() {&#10;        String observationText = etObservationText.getText().toString().trim();&#10;        String observationTime = etObservationTime.getText().toString().trim();&#10;        String comments = etComments.getText().toString().trim();&#10;&#10;        // Validation through ViewModel&#10;        if (!viewModel.validateObservation(observationText, observationTime)) {&#10;            if (observationText.isEmpty()) {&#10;                etObservationText.setError(&quot;Observation text is required&quot;);&#10;                etObservationText.requestFocus();&#10;            } else if (observationTime.isEmpty()) {&#10;                etObservationTime.setError(&quot;Observation time is required&quot;);&#10;                etObservationTime.requestFocus();&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Update observation object&#10;        currentObservation.setObservationText(observationText);&#10;        currentObservation.setObservationTime(observationTime);&#10;        currentObservation.setComments(comments);&#10;        currentObservation.setPhotoPath(currentPhotoPath); // Update photo path&#10;&#10;        // Update through ViewModel&#10;        viewModel.updateObservation(currentObservation);&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        if (repository != null) {&#10;            repository.shutdown();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.hikenativeapp.ui.edit_observation;&#10;&#10;import android.Manifest;&#10;import android.app.DatePickerDialog;&#10;import android.app.TimePickerDialog;&#10;import android.content.Intent;&#10;import android.content.pm.PackageManager;&#10;import android.net.Uri;&#10;import android.os.Build;&#10;import android.os.Bundle;&#10;import android.os.Environment;&#10;import android.provider.MediaStore;&#10;import android.view.View;&#10;import android.widget.Button;&#10;import android.widget.EditText;&#10;import android.widget.ImageView;&#10;import android.widget.ProgressBar;&#10;import android.widget.Toast;&#10;&#10;import androidx.activity.result.ActivityResultLauncher;&#10;import androidx.activity.result.contract.ActivityResultContracts;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.appcompat.widget.Toolbar;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.core.content.FileProvider;&#10;import androidx.lifecycle.ViewModelProvider;&#10;&#10;import com.bumptech.glide.Glide;&#10;import com.example.hikenativeapp.R;&#10;import com.example.hikenativeapp.data.local.entity.Observation;&#10;import com.example.hikenativeapp.data.repository.ObservationRepository;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;import java.util.Locale;&#10;&#10;public class EditObservationActivity extends AppCompatActivity {&#10;&#10;    private EditText etObservationText, etObservationTime, etComments;&#10;    private Button btnSave, btnCancel, btnSelectTime, btnTakePhoto, btnRemovePhoto, btnSelectPhoto;&#10;    private ImageView ivObservationPhoto;&#10;    private Toolbar toolbar;&#10;    private ProgressBar progressBar;&#10;&#10;    private EditObservationViewModel viewModel;&#10;    private ObservationRepository repository;&#10;    private int observationId;&#10;    private int hikeId;&#10;    private String hikeName;&#10;    private Observation currentObservation;&#10;    private Calendar selectedDateTime;&#10;    private boolean viewMode = false;&#10;    private String currentPhotoPath;&#10;&#10;    // Activity Result Launchers&#10;    private ActivityResultLauncher&lt;Intent&gt; takePictureLauncher;&#10;    private ActivityResultLauncher&lt;String[]&gt; requestPermissionLauncher;&#10;    private ActivityResultLauncher&lt;String&gt; selectPictureLauncher;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_edit_observation);&#10;&#10;        // Get data from intent&#10;        observationId = getIntent().getIntExtra(&quot;OBSERVATION_ID&quot;, -1);&#10;        hikeId = getIntent().getIntExtra(&quot;HIKE_ID&quot;, -1);&#10;        hikeName = getIntent().getStringExtra(&quot;HIKE_NAME&quot;);&#10;        viewMode = getIntent().getBooleanExtra(&quot;VIEW_MODE&quot;, false);&#10;&#10;        if (observationId == -1 || hikeId == -1) {&#10;            Toast.makeText(this, &quot;Invalid observation&quot;, Toast.LENGTH_SHORT).show();&#10;            finish();&#10;            return;&#10;        }&#10;&#10;        initializeActivityResultLaunchers();&#10;        initializeComponents();&#10;        setupViewModel();&#10;        setupListeners();&#10;        observeViewModel();&#10;&#10;        // Load observation through ViewModel&#10;        viewModel.loadObservation(observationId);&#10;    }&#10;&#10;    private void initializeActivityResultLaunchers() {&#10;        // Camera launcher&#10;        takePictureLauncher = registerForActivityResult(&#10;            new ActivityResultContracts.StartActivityForResult(),&#10;            result -&gt; {&#10;                if (result.getResultCode() == RESULT_OK) {&#10;                    // Photo saved to currentPhotoPath&#10;                    displayPhoto();&#10;                }&#10;            }&#10;        );&#10;&#10;        // Permission launcher&#10;        requestPermissionLauncher = registerForActivityResult(&#10;            new ActivityResultContracts.RequestMultiplePermissions(),&#10;            permissions -&gt; {&#10;                boolean allGranted = true;&#10;                for (Boolean granted : permissions.values()) {&#10;                    if (!granted) {&#10;                        allGranted = false;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (allGranted) {&#10;                    dispatchTakePictureIntent();&#10;                } else {&#10;                    Toast.makeText(this, &quot;Camera and storage permissions are required&quot;, Toast.LENGTH_SHORT).show();&#10;                }&#10;            }&#10;        );&#10;&#10;        // Gallery launcher&#10;        selectPictureLauncher = registerForActivityResult(&#10;            new ActivityResultContracts.GetContent(),&#10;            result -&gt; {&#10;                if (result != null) {&#10;                    // Got image Uri from gallery&#10;                    currentPhotoPath = result.toString();&#10;                    displayPhoto();&#10;                }&#10;            }&#10;        );&#10;    }&#10;&#10;    private void initializeComponents() {&#10;        toolbar = findViewById(R.id.toolbar);&#10;        etObservationText = findViewById(R.id.et_observation_text);&#10;        etObservationTime = findViewById(R.id.et_observation_time);&#10;        etComments = findViewById(R.id.et_comments);&#10;        btnSave = findViewById(R.id.btn_save);&#10;        btnCancel = findViewById(R.id.btn_cancel);&#10;        btnSelectTime = findViewById(R.id.btn_select_time);&#10;        btnTakePhoto = findViewById(R.id.btn_take_photo);&#10;        btnRemovePhoto = findViewById(R.id.btn_remove_photo);&#10;        btnSelectPhoto = findViewById(R.id.btn_select_photo);&#10;        ivObservationPhoto = findViewById(R.id.iv_observation_photo);&#10;        progressBar = findViewById(R.id.progress_bar);&#10;&#10;        repository = new ObservationRepository(this);&#10;        selectedDateTime = Calendar.getInstance();&#10;&#10;        // Setup Toolbar&#10;        setSupportActionBar(toolbar);&#10;        if (getSupportActionBar() != null) {&#10;            getSupportActionBar().setTitle(viewMode ? &quot;View Observation&quot; : &quot;Edit Observation&quot;);&#10;            getSupportActionBar().setDisplayHomeAsUpEnabled(true);&#10;        }&#10;&#10;        // If view mode, disable all inputs&#10;        if (viewMode) {&#10;            etObservationText.setEnabled(false);&#10;            etObservationTime.setEnabled(false);&#10;            etComments.setEnabled(false);&#10;            btnSelectTime.setEnabled(false);&#10;            btnTakePhoto.setEnabled(false);&#10;            btnSelectPhoto.setEnabled(false);&#10;            btnSave.setVisibility(View.GONE);&#10;        }&#10;    }&#10;&#10;    private void setupViewModel() {&#10;        viewModel = new ViewModelProvider(this).get(EditObservationViewModel.class);&#10;        viewModel.setRepository(repository);&#10;    }&#10;&#10;    private void observeViewModel() {&#10;        // Observe observation data&#10;        viewModel.observation.observe(this, observation -&gt; {&#10;            if (observation != null) {&#10;                currentObservation = observation;&#10;                displayObservation();&#10;            }&#10;        });&#10;&#10;        // Observe update success&#10;        viewModel.updateSuccess.observe(this, success -&gt; {&#10;            if (success != null &amp;&amp; success) {&#10;                Toast.makeText(this, &quot;Observation updated successfully&quot;, Toast.LENGTH_SHORT).show();&#10;                finish();&#10;            }&#10;        });&#10;&#10;        // Observe error messages&#10;        viewModel.errorMessage.observe(this, error -&gt; {&#10;            if (error != null &amp;&amp; !error.isEmpty()) {&#10;                Toast.makeText(this, error, Toast.LENGTH_SHORT).show();&#10;            }&#10;        });&#10;&#10;        // Observe loading state&#10;        viewModel.isLoading.observe(this, isLoading -&gt; {&#10;            if (isLoading != null) {&#10;                if (isLoading) {&#10;                    progressBar.setVisibility(View.VISIBLE);&#10;                    btnSave.setEnabled(false);&#10;                } else {&#10;                    progressBar.setVisibility(View.GONE);&#10;                    btnSave.setEnabled(true);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private void setupListeners() {&#10;        btnSelectTime.setOnClickListener(v -&gt; showDateTimePicker());&#10;&#10;        btnSave.setOnClickListener(v -&gt; updateObservation());&#10;&#10;        btnCancel.setOnClickListener(v -&gt; finish());&#10;&#10;        toolbar.setNavigationOnClickListener(v -&gt; finish());&#10;&#10;        btnTakePhoto.setOnClickListener(v -&gt; checkCameraAndStoragePermissions());&#10;&#10;        btnSelectPhoto.setOnClickListener(v -&gt; selectPictureFromGallery());&#10;&#10;        btnRemovePhoto.setOnClickListener(v -&gt; removePhoto());&#10;    }&#10;&#10;    private void displayObservation() {&#10;        etObservationText.setText(currentObservation.getObservationText());&#10;        etObservationTime.setText(currentObservation.getObservationTime());&#10;        etComments.setText(currentObservation.getComments());&#10;&#10;        // Display existing photo if available&#10;        currentPhotoPath = currentObservation.getPhotoPath();&#10;        if (currentPhotoPath != null &amp;&amp; !currentPhotoPath.isEmpty()) {&#10;            displayPhoto();&#10;        }&#10;    }&#10;&#10;    private void showDateTimePicker() {&#10;        // Show date picker first&#10;        DatePickerDialog datePickerDialog = new DatePickerDialog(&#10;            this,&#10;            (view, year, month, dayOfMonth) -&gt; {&#10;                selectedDateTime.set(Calendar.YEAR, year);&#10;                selectedDateTime.set(Calendar.MONTH, month);&#10;                selectedDateTime.set(Calendar.DAY_OF_MONTH, dayOfMonth);&#10;&#10;                // Then show time picker&#10;                showTimePicker();&#10;            },&#10;            selectedDateTime.get(Calendar.YEAR),&#10;            selectedDateTime.get(Calendar.MONTH),&#10;            selectedDateTime.get(Calendar.DAY_OF_MONTH)&#10;        );&#10;        datePickerDialog.show();&#10;    }&#10;&#10;    private void showTimePicker() {&#10;        TimePickerDialog timePickerDialog = new TimePickerDialog(&#10;            this,&#10;            (view, hourOfDay, minute) -&gt; {&#10;                selectedDateTime.set(Calendar.HOUR_OF_DAY, hourOfDay);&#10;                selectedDateTime.set(Calendar.MINUTE, minute);&#10;                updateTimeDisplay();&#10;            },&#10;            selectedDateTime.get(Calendar.HOUR_OF_DAY),&#10;            selectedDateTime.get(Calendar.MINUTE),&#10;            true&#10;        );&#10;        timePickerDialog.show();&#10;    }&#10;&#10;    private void updateTimeDisplay() {&#10;        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;, Locale.getDefault());&#10;        etObservationTime.setText(sdf.format(selectedDateTime.getTime()));&#10;    }&#10;&#10;    private void checkCameraAndStoragePermissions() {&#10;        String[] permissions;&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            permissions = new String[]{&#10;                Manifest.permission.CAMERA,&#10;                Manifest.permission.READ_MEDIA_IMAGES&#10;            };&#10;        } else {&#10;            permissions = new String[]{&#10;                Manifest.permission.CAMERA,&#10;                Manifest.permission.READ_EXTERNAL_STORAGE,&#10;                Manifest.permission.WRITE_EXTERNAL_STORAGE&#10;            };&#10;        }&#10;&#10;        boolean allPermissionsGranted = true;&#10;        for (String permission : permissions) {&#10;            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {&#10;                allPermissionsGranted = false;&#10;                break;&#10;            }&#10;        }&#10;&#10;        if (allPermissionsGranted) {&#10;            dispatchTakePictureIntent();&#10;        } else {&#10;            requestPermissionLauncher.launch(permissions);&#10;        }&#10;    }&#10;&#10;    private void dispatchTakePictureIntent() {&#10;        Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);&#10;&#10;        if (takePictureIntent.resolveActivity(getPackageManager()) != null) {&#10;            File photoFile = null;&#10;            try {&#10;                photoFile = createImageFile();&#10;            } catch (IOException ex) {&#10;                Toast.makeText(this, &quot;Error creating image file&quot;, Toast.LENGTH_SHORT).show();&#10;                return;&#10;            }&#10;&#10;            if (photoFile != null) {&#10;                Uri photoURI = FileProvider.getUriForFile(&#10;                    this,&#10;                    getPackageName() + &quot;.fileprovider&quot;,&#10;                    photoFile&#10;                );&#10;                takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);&#10;                takePictureLauncher.launch(takePictureIntent);&#10;            }&#10;        } else {&#10;            Toast.makeText(this, &quot;No camera app found&quot;, Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;&#10;    private File createImageFile() throws IOException {&#10;        String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;, Locale.getDefault()).format(new Date());&#10;        String imageFileName = &quot;OBSERVATION_&quot; + timeStamp + &quot;_&quot;;&#10;        File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);&#10;&#10;        File image = File.createTempFile(&#10;            imageFileName,&#10;            &quot;.jpg&quot;,&#10;            storageDir&#10;        );&#10;&#10;        currentPhotoPath = image.getAbsolutePath();&#10;        return image;&#10;    }&#10;&#10;    private void displayPhoto() {&#10;        if (currentPhotoPath != null &amp;&amp; !currentPhotoPath.isEmpty()) {&#10;            // Glide can handle both File paths and Content URIs&#10;            Glide.with(this)&#10;                    .load(currentPhotoPath)&#10;                    .centerCrop()&#10;                    .into(ivObservationPhoto);&#10;&#10;            ivObservationPhoto.setVisibility(View.VISIBLE);&#10;            btnRemovePhoto.setVisibility(viewMode ? View.GONE : View.VISIBLE);&#10;        }&#10;    }&#10;&#10;    private void selectPictureFromGallery() {&#10;        // Launch gallery to select picture&#10;        selectPictureLauncher.launch(&quot;image/*&quot;);&#10;    }&#10;&#10;    private void removePhoto() {&#10;        // Only delete file if it's a file path (not a content URI)&#10;        if (currentPhotoPath != null &amp;&amp; !currentPhotoPath.isEmpty() &amp;&amp; !currentPhotoPath.startsWith(&quot;content://&quot;)) {&#10;            File photoFile = new File(currentPhotoPath);&#10;            if (photoFile.exists()) {&#10;                photoFile.delete();&#10;            }&#10;        }&#10;&#10;        currentPhotoPath = null;&#10;        ivObservationPhoto.setVisibility(View.GONE);&#10;        btnRemovePhoto.setVisibility(View.GONE);&#10;&#10;        // Clear the ImageView&#10;        Glide.with(this).clear(ivObservationPhoto);&#10;    }&#10;&#10;    private void updateObservation() {&#10;        String observationText = etObservationText.getText().toString().trim();&#10;        String observationTime = etObservationTime.getText().toString().trim();&#10;        String comments = etComments.getText().toString().trim();&#10;&#10;        // Validation through ViewModel&#10;        if (!viewModel.validateObservation(observationText, observationTime)) {&#10;            if (observationText.isEmpty()) {&#10;                etObservationText.setError(&quot;Observation text is required&quot;);&#10;                etObservationText.requestFocus();&#10;            } else if (observationTime.isEmpty()) {&#10;                etObservationTime.setError(&quot;Observation time is required&quot;);&#10;                etObservationTime.requestFocus();&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Update observation object&#10;        currentObservation.setObservationText(observationText);&#10;        currentObservation.setObservationTime(observationTime);&#10;        currentObservation.setComments(comments);&#10;        currentObservation.setPhotoPath(currentPhotoPath); // Update photo path&#10;&#10;        // Update through ViewModel&#10;        viewModel.updateObservation(currentObservation);&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        if (repository != null) {&#10;            repository.shutdown();&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/ui/hike_detail/ConfirmHikeActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/ui/hike_detail/ConfirmHikeActivity.java" />
              <option name="originalContent" value="package com.example.hikenativeapp.ui.hike_detail;&#10;&#10;import android.content.Intent;&#10;import android.content.SharedPreferences;&#10;import android.os.Bundle;&#10;import android.widget.Button;&#10;import android.widget.TextView;&#10;import android.widget.Toast;&#10;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.appcompat.widget.Toolbar;&#10;&#10;import com.example.hikenativeapp.R;&#10;import com.example.hikenativeapp.data.local.entity.Hike;&#10;import com.example.hikenativeapp.data.repository.HikeRepository;&#10;import com.example.hikenativeapp.ui.hike_list.HikeListActivity;&#10;import com.example.hikenativeapp.util.Constants;&#10;&#10;public class ConfirmHikeActivity extends AppCompatActivity {&#10;&#10;    private TextView tvName, tvLocation, tvDate, tvParking, tvLength, tvDifficulty;&#10;    private TextView tvDescription, tvWeatherCondition, tvEstimatedDuration;&#10;    private Button btnConfirm, btnEdit;&#10;    private Toolbar toolbar;&#10;&#10;    private HikeRepository repository;&#10;    private String name, location, date, difficulty, description, weatherCondition, estimatedDuration;&#10;    private boolean parkingAvailable;&#10;    private double length;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_confirm_hike);&#10;&#10;        initializeViews();&#10;        repository = new HikeRepository(this);&#10;        loadDataFromIntent();&#10;        displayHikeDetails();&#10;        setupClickListeners();&#10;    }&#10;&#10;    private void initializeViews() {&#10;        tvName = findViewById(R.id.tv_name);&#10;        tvLocation = findViewById(R.id.tv_location);&#10;        tvDate = findViewById(R.id.tv_date);&#10;        tvParking = findViewById(R.id.tv_parking);&#10;        tvLength = findViewById(R.id.tv_length);&#10;        tvDifficulty = findViewById(R.id.tv_difficulty);&#10;        tvDescription = findViewById(R.id.tv_description);&#10;        tvWeatherCondition = findViewById(R.id.tv_weather_condition);&#10;        tvEstimatedDuration = findViewById(R.id.tv_estimated_duration);&#10;&#10;        btnConfirm = findViewById(R.id.btn_confirm);&#10;        btnEdit = findViewById(R.id.btn_edit);&#10;        toolbar = findViewById(R.id.toolbar);&#10;&#10;        // Setup Toolbar as ActionBar&#10;        setSupportActionBar(toolbar);&#10;        if (getSupportActionBar() != null) {&#10;            getSupportActionBar().setTitle(&quot;Confirm Hike Details&quot;);&#10;            getSupportActionBar().setDisplayHomeAsUpEnabled(true);&#10;            getSupportActionBar().setDisplayShowHomeEnabled(true);&#10;        }&#10;    }&#10;&#10;    private void loadDataFromIntent() {&#10;        Intent intent = getIntent();&#10;        name = intent.getStringExtra(&quot;name&quot;);&#10;        location = intent.getStringExtra(&quot;location&quot;);&#10;        date = intent.getStringExtra(&quot;date&quot;);&#10;        parkingAvailable = intent.getBooleanExtra(&quot;parking_available&quot;, false);&#10;        length = intent.getDoubleExtra(&quot;length&quot;, 0.0);&#10;        difficulty = intent.getStringExtra(&quot;difficulty&quot;);&#10;        description = intent.getStringExtra(&quot;description&quot;);&#10;        weatherCondition = intent.getStringExtra(&quot;weather_condition&quot;);&#10;        estimatedDuration = intent.getStringExtra(&quot;estimated_duration&quot;);&#10;    }&#10;&#10;    private void displayHikeDetails() {&#10;        tvName.setText(name);&#10;        tvLocation.setText(location);&#10;        tvDate.setText(date);&#10;        tvParking.setText(parkingAvailable ? &quot;Yes&quot; : &quot;No&quot;);&#10;        tvLength.setText(String.format(&quot;%.1f km&quot;, length));&#10;        tvDifficulty.setText(difficulty);&#10;        tvDescription.setText(description.isEmpty() ? &quot;No description provided&quot; : description);&#10;        tvWeatherCondition.setText(weatherCondition);&#10;        tvEstimatedDuration.setText(estimatedDuration + &quot; hours&quot;);&#10;    }&#10;&#10;    private void setupClickListeners() {&#10;        btnConfirm.setOnClickListener(v -&gt; saveHike());&#10;        btnEdit.setOnClickListener(v -&gt; goBackToEdit());&#10;    }&#10;&#10;    private void saveHike() {&#10;        // Get current user ID&#10;        SharedPreferences prefs = getSharedPreferences(Constants.PREFS_NAME, MODE_PRIVATE);&#10;        int userId = prefs.getInt(Constants.PREF_USER_ID, -1);&#10;&#10;        if (userId == -1) {&#10;            Toast.makeText(this, &quot;Error: User not found&quot;, Toast.LENGTH_SHORT).show();&#10;            return;&#10;        }&#10;&#10;        // Create hike object&#10;        Hike hike = new Hike();&#10;        hike.setUserId(userId);&#10;        hike.setName(name);&#10;        hike.setLocation(location);&#10;        hike.setHikeDate(date);&#10;        hike.setParkingAvailable(parkingAvailable);&#10;        hike.setLength(length);&#10;        hike.setDifficulty(difficulty);&#10;        hike.setDescription(description);&#10;&#10;        // Save to database&#10;        new Thread(() -&gt; {&#10;            try {&#10;                long hikeId = repository.insertHike(hike).get();&#10;                runOnUiThread(() -&gt; {&#10;                    if (hikeId &gt; 0) {&#10;                        Toast.makeText(this, &quot;Hike saved successfully!&quot;, Toast.LENGTH_SHORT).show();&#10;                        navigateToHikeList();&#10;                    } else {&#10;                        Toast.makeText(this, &quot;Failed to save hike&quot;, Toast.LENGTH_SHORT).show();&#10;                    }&#10;                });&#10;            } catch (Exception e) {&#10;                runOnUiThread(() -&gt; {&#10;                    Toast.makeText(this, &quot;Error saving hike: &quot; + e.getMessage(), Toast.LENGTH_SHORT).show();&#10;                });&#10;            }&#10;        }).start();&#10;    }&#10;&#10;    private void goBackToEdit() {&#10;        onBackPressed();&#10;    }&#10;&#10;    private void navigateToHikeList() {&#10;        Intent intent = new Intent(this, HikeListActivity.class);&#10;        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);&#10;        startActivity(intent);&#10;        finish();&#10;    }&#10;&#10;    @Override&#10;    public boolean onSupportNavigateUp() {&#10;        onBackPressed();&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        if (repository != null) {&#10;            repository.cleanup();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.hikenativeapp.ui.confirm_hike;&#13;&#10;&#13;&#10;import android.content.Intent;&#13;&#10;import android.content.SharedPreferences;&#13;&#10;import android.os.Bundle;&#13;&#10;import android.widget.Button;&#13;&#10;import android.widget.TextView;&#13;&#10;import android.widget.Toast;&#13;&#10;&#13;&#10;import androidx.appcompat.app.AppCompatActivity;&#13;&#10;import androidx.appcompat.widget.Toolbar;&#13;&#10;&#13;&#10;import com.example.hikenativeapp.R;&#13;&#10;import com.example.hikenativeapp.data.local.entity.Hike;&#13;&#10;import com.example.hikenativeapp.data.repository.HikeRepository;&#13;&#10;import com.example.hikenativeapp.ui.hike_list.HikeListActivity;&#13;&#10;import com.example.hikenativeapp.util.Constants;&#13;&#10;&#13;&#10;public class ConfirmHikeActivity extends AppCompatActivity {&#13;&#10;&#13;&#10;    private TextView tvName, tvLocation, tvDate, tvParking, tvLength, tvDifficulty;&#13;&#10;    private TextView tvDescription, tvWeatherCondition, tvEstimatedDuration;&#13;&#10;    private Button btnConfirm, btnEdit;&#13;&#10;    private Toolbar toolbar;&#13;&#10;&#13;&#10;    private HikeRepository repository;&#13;&#10;    private String name, location, date, difficulty, description, weatherCondition, estimatedDuration;&#13;&#10;    private boolean parkingAvailable;&#13;&#10;    private double length;&#13;&#10;&#13;&#10;    @Override&#13;&#10;    protected void onCreate(Bundle savedInstanceState) {&#13;&#10;        super.onCreate(savedInstanceState);&#13;&#10;        setContentView(R.layout.activity_confirm_hike);&#13;&#10;&#13;&#10;        initializeViews();&#13;&#10;        repository = new HikeRepository(this);&#13;&#10;        loadDataFromIntent();&#13;&#10;        displayHikeDetails();&#13;&#10;        setupClickListeners();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void initializeViews() {&#13;&#10;        tvName = findViewById(R.id.tv_name);&#13;&#10;        tvLocation = findViewById(R.id.tv_location);&#13;&#10;        tvDate = findViewById(R.id.tv_date);&#13;&#10;        tvParking = findViewById(R.id.tv_parking);&#13;&#10;        tvLength = findViewById(R.id.tv_length);&#13;&#10;        tvDifficulty = findViewById(R.id.tv_difficulty);&#13;&#10;        tvDescription = findViewById(R.id.tv_description);&#13;&#10;        tvWeatherCondition = findViewById(R.id.tv_weather_condition);&#13;&#10;        tvEstimatedDuration = findViewById(R.id.tv_estimated_duration);&#13;&#10;&#13;&#10;        btnConfirm = findViewById(R.id.btn_confirm);&#13;&#10;        btnEdit = findViewById(R.id.btn_edit);&#13;&#10;        toolbar = findViewById(R.id.toolbar);&#13;&#10;&#13;&#10;        // Setup Toolbar as ActionBar&#13;&#10;        setSupportActionBar(toolbar);&#13;&#10;        if (getSupportActionBar() != null) {&#13;&#10;            getSupportActionBar().setTitle(&quot;Confirm Hike Details&quot;);&#13;&#10;            getSupportActionBar().setDisplayHomeAsUpEnabled(true);&#13;&#10;            getSupportActionBar().setDisplayShowHomeEnabled(true);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void loadDataFromIntent() {&#13;&#10;        Intent intent = getIntent();&#13;&#10;        name = intent.getStringExtra(&quot;name&quot;);&#13;&#10;        location = intent.getStringExtra(&quot;location&quot;);&#13;&#10;        date = intent.getStringExtra(&quot;date&quot;);&#13;&#10;        parkingAvailable = intent.getBooleanExtra(&quot;parking_available&quot;, false);&#13;&#10;        length = intent.getDoubleExtra(&quot;length&quot;, 0.0);&#13;&#10;        difficulty = intent.getStringExtra(&quot;difficulty&quot;);&#13;&#10;        description = intent.getStringExtra(&quot;description&quot;);&#13;&#10;        weatherCondition = intent.getStringExtra(&quot;weather_condition&quot;);&#13;&#10;        estimatedDuration = intent.getStringExtra(&quot;estimated_duration&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void displayHikeDetails() {&#13;&#10;        tvName.setText(name);&#13;&#10;        tvLocation.setText(location);&#13;&#10;        tvDate.setText(date);&#13;&#10;        tvParking.setText(parkingAvailable ? &quot;Yes&quot; : &quot;No&quot;);&#13;&#10;        tvLength.setText(String.format(&quot;%.1f km&quot;, length));&#13;&#10;        tvDifficulty.setText(difficulty);&#13;&#10;        tvDescription.setText(description.isEmpty() ? &quot;No description provided&quot; : description);&#13;&#10;        tvWeatherCondition.setText(weatherCondition);&#13;&#10;        tvEstimatedDuration.setText(estimatedDuration + &quot; hours&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void setupClickListeners() {&#13;&#10;        btnConfirm.setOnClickListener(v -&gt; saveHike());&#13;&#10;        btnEdit.setOnClickListener(v -&gt; goBackToEdit());&#13;&#10;    }&#13;&#10;&#13;&#10;    private void saveHike() {&#13;&#10;        // Get current user ID&#13;&#10;        SharedPreferences prefs = getSharedPreferences(Constants.PREFS_NAME, MODE_PRIVATE);&#13;&#10;        int userId = prefs.getInt(Constants.PREF_USER_ID, -1);&#13;&#10;&#13;&#10;        if (userId == -1) {&#13;&#10;            Toast.makeText(this, &quot;Error: User not found&quot;, Toast.LENGTH_SHORT).show();&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        // Create hike object&#13;&#10;        Hike hike = new Hike();&#13;&#10;        hike.setUserId(userId);&#13;&#10;        hike.setName(name);&#13;&#10;        hike.setLocation(location);&#13;&#10;        hike.setHikeDate(date);&#13;&#10;        hike.setParkingAvailable(parkingAvailable);&#13;&#10;        hike.setLength(length);&#13;&#10;        hike.setDifficulty(difficulty);&#13;&#10;        hike.setDescription(description);&#13;&#10;&#13;&#10;        // Save to database&#13;&#10;        new Thread(() -&gt; {&#13;&#10;            try {&#13;&#10;                long hikeId = repository.insertHike(hike).get();&#13;&#10;                runOnUiThread(() -&gt; {&#13;&#10;                    if (hikeId &gt; 0) {&#13;&#10;                        Toast.makeText(this, &quot;Hike saved successfully!&quot;, Toast.LENGTH_SHORT).show();&#13;&#10;                        navigateToHikeList();&#13;&#10;                    } else {&#13;&#10;                        Toast.makeText(this, &quot;Failed to save hike&quot;, Toast.LENGTH_SHORT).show();&#13;&#10;                    }&#13;&#10;                });&#13;&#10;            } catch (Exception e) {&#13;&#10;                runOnUiThread(() -&gt; {&#13;&#10;                    Toast.makeText(this, &quot;Error saving hike: &quot; + e.getMessage(), Toast.LENGTH_SHORT).show();&#13;&#10;                });&#13;&#10;            }&#13;&#10;        }).start();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void goBackToEdit() {&#13;&#10;        onBackPressed();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void navigateToHikeList() {&#13;&#10;        Intent intent = new Intent(this, HikeListActivity.class);&#13;&#10;        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);&#13;&#10;        startActivity(intent);&#13;&#10;        finish();&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public boolean onSupportNavigateUp() {&#13;&#10;        onBackPressed();&#13;&#10;        return true;&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    protected void onDestroy() {&#13;&#10;        super.onDestroy();&#13;&#10;        if (repository != null) {&#13;&#10;            repository.cleanup();&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/ui/hike_list/SwipeToDeleteCallback.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/ui/hike_list/SwipeToDeleteCallback.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.hikenativeapp.ui.hike_list;&#10;&#10;import android.content.Context;&#10;import android.graphics.Canvas;&#10;import android.graphics.Color;&#10;import android.graphics.drawable.ColorDrawable;&#10;import android.graphics.drawable.Drawable;&#10;import android.view.View;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.recyclerview.widget.ItemTouchHelper;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;&#10;import com.example.hikenativeapp.R;&#10;&#10;public class SwipeToDeleteCallback extends ItemTouchHelper.SimpleCallback {&#10;&#10;    private HikeAdapter adapter;&#10;    private Drawable deleteIcon;&#10;    private int intrinsicWidth;&#10;    private int intrinsicHeight;&#10;    private ColorDrawable background;&#10;    private int backgroundColor;&#10;    private OnSwipeListener onSwipeListener;&#10;&#10;    public interface OnSwipeListener {&#10;        void onSwipe(int position);&#10;    }&#10;&#10;    public SwipeToDeleteCallback(Context context, HikeAdapter adapter, OnSwipeListener listener) {&#10;        super(0, ItemTouchHelper.LEFT);&#10;        this.adapter = adapter;&#10;        this.onSwipeListener = listener;&#10;&#10;        // Initialize delete icon and background&#10;        deleteIcon = ContextCompat.getDrawable(context, R.drawable.ic_delete_white);&#10;        if (deleteIcon != null) {&#10;            intrinsicWidth = deleteIcon.getIntrinsicWidth();&#10;            intrinsicHeight = deleteIcon.getIntrinsicHeight();&#10;        }&#10;&#10;        backgroundColor = Color.parseColor(&quot;#f44336&quot;); // Red color&#10;        background = new ColorDrawable();&#10;    }&#10;&#10;    @Override&#10;    public boolean onMove(@NonNull RecyclerView recyclerView, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull RecyclerView.ViewHolder target) {&#10;        return false;&#10;    }&#10;&#10;    @Override&#10;    public void onSwiped(@NonNull RecyclerView.ViewHolder viewHolder, int direction) {&#10;        int position = viewHolder.getAdapterPosition();&#10;        if (onSwipeListener != null) {&#10;            onSwipeListener.onSwipe(position);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onChildDraw(@NonNull Canvas c, @NonNull RecyclerView recyclerView, @NonNull RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) {&#10;        super.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);&#10;&#10;        View itemView = viewHolder.itemView;&#10;        int itemHeight = itemView.getBottom() - itemView.getTop();&#10;&#10;        // Draw red background&#10;        background.setColor(backgroundColor);&#10;        background.setBounds(&#10;            itemView.getRight() + ((int) dX),&#10;            itemView.getTop(),&#10;            itemView.getRight(),&#10;            itemView.getBottom()&#10;        );&#10;        background.draw(c);&#10;&#10;        // Draw delete icon&#10;        if (deleteIcon != null) {&#10;            int deleteIconTop = itemView.getTop() + (itemHeight - intrinsicHeight) / 2;&#10;            int deleteIconMargin = (itemHeight - intrinsicHeight) / 2;&#10;            int deleteIconLeft = itemView.getRight() - deleteIconMargin - intrinsicWidth;&#10;            int deleteIconRight = itemView.getRight() - deleteIconMargin;&#10;            int deleteIconBottom = deleteIconTop + intrinsicHeight;&#10;&#10;            deleteIcon.setBounds(deleteIconLeft, deleteIconTop, deleteIconRight, deleteIconBottom);&#10;            deleteIcon.draw(c);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public float getSwipeThreshold(@NonNull RecyclerView.ViewHolder viewHolder) {&#10;        return 0.7f; // Require 70% swipe to trigger delete&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/util/UserValidator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/util/UserValidator.java" />
              <option name="updatedContent" value="package com.example.hikenativeapp.util;&#10;&#10;import android.text.TextUtils;&#10;import android.util.Patterns;&#10;&#10;/**&#10; * Validator for User-related data&#10; */&#10;public class UserValidator {&#10;&#10;    // Minimum and maximum length for display name&#10;    private static final int MIN_DISPLAY_NAME_LENGTH = 2;&#10;    private static final int MAX_DISPLAY_NAME_LENGTH = 50;&#10;&#10;    /**&#10;     * Validates display name&#10;     * @param displayName The display name to validate&#10;     * @return ValidationResult containing validity status and error message&#10;     */&#10;    public static ValidationResult validateDisplayName(String displayName) {&#10;        if (TextUtils.isEmpty(displayName)) {&#10;            return new ValidationResult(false, &quot;Display name cannot be empty&quot;);&#10;        }&#10;&#10;        String trimmed = displayName.trim();&#10;        &#10;        if (trimmed.isEmpty()) {&#10;            return new ValidationResult(false, &quot;Display name cannot be empty or contain only spaces&quot;);&#10;        }&#10;&#10;        if (trimmed.length() &lt; MIN_DISPLAY_NAME_LENGTH) {&#10;            return new ValidationResult(false, &quot;Display name must be at least &quot; + MIN_DISPLAY_NAME_LENGTH + &quot; characters&quot;);&#10;        }&#10;&#10;        if (trimmed.length() &gt; MAX_DISPLAY_NAME_LENGTH) {&#10;            return new ValidationResult(false, &quot;Display name cannot exceed &quot; + MAX_DISPLAY_NAME_LENGTH + &quot; characters&quot;);&#10;        }&#10;&#10;        // Check for invalid characters (optional - you can customize this)&#10;        if (!trimmed.matches(&quot;^[a-zA-Z0-9\\s._-]+$&quot;)) {&#10;            return new ValidationResult(false, &quot;Display name can only contain letters, numbers, spaces, and ._- characters&quot;);&#10;        }&#10;&#10;        return new ValidationResult(true, &quot;Valid display name&quot;);&#10;    }&#10;&#10;    /**&#10;     * Validates email address&#10;     * @param email The email to validate&#10;     * @return ValidationResult containing validity status and error message&#10;     */&#10;    public static ValidationResult validateEmail(String email) {&#10;        if (TextUtils.isEmpty(email)) {&#10;            return new ValidationResult(false, &quot;Email cannot be empty&quot;);&#10;        }&#10;&#10;        String trimmed = email.trim();&#10;&#10;        if (!Patterns.EMAIL_ADDRESS.matcher(trimmed).matches()) {&#10;            return new ValidationResult(false, &quot;Invalid email format&quot;);&#10;        }&#10;&#10;        return new ValidationResult(true, &quot;Valid email&quot;);&#10;    }&#10;&#10;    /**&#10;     * Validates Google ID&#10;     * @param googleId The Google ID to validate&#10;     * @return ValidationResult containing validity status and error message&#10;     */&#10;    public static ValidationResult validateGoogleId(String googleId) {&#10;        if (TextUtils.isEmpty(googleId)) {&#10;            return new ValidationResult(false, &quot;Google ID cannot be empty&quot;);&#10;        }&#10;&#10;        String trimmed = googleId.trim();&#10;&#10;        if (trimmed.isEmpty()) {&#10;            return new ValidationResult(false, &quot;Google ID cannot be empty&quot;);&#10;        }&#10;&#10;        // Google IDs are typically alphanumeric&#10;        if (!trimmed.matches(&quot;^[a-zA-Z0-9]+$&quot;)) {&#10;            return new ValidationResult(false, &quot;Invalid Google ID format&quot;);&#10;        }&#10;&#10;        return new ValidationResult(true, &quot;Valid Google ID&quot;);&#10;    }&#10;&#10;    /**&#10;     * Validates photo URL&#10;     * @param photoUrl The photo URL to validate&#10;     * @return ValidationResult containing validity status and error message&#10;     */&#10;    public static ValidationResult validatePhotoUrl(String photoUrl) {&#10;        // Photo URL is optional, so null or empty is valid&#10;        if (TextUtils.isEmpty(photoUrl)) {&#10;            return new ValidationResult(true, &quot;Photo URL is optional&quot;);&#10;        }&#10;&#10;        String trimmed = photoUrl.trim();&#10;&#10;        if (!Patterns.WEB_URL.matcher(trimmed).matches()) {&#10;            return new ValidationResult(false, &quot;Invalid photo URL format&quot;);&#10;        }&#10;&#10;        return new ValidationResult(true, &quot;Valid photo URL&quot;);&#10;    }&#10;&#10;    /**&#10;     * Validates complete user data&#10;     * @param googleId Google ID&#10;     * @param email Email address&#10;     * @param displayName Display name&#10;     * @param photoUrl Photo URL (optional)&#10;     * @return ValidationResult containing validity status and error message&#10;     */&#10;    public static ValidationResult validateUserData(String googleId, String email, &#10;                                                    String displayName, String photoUrl) {&#10;        // Validate Google ID&#10;        ValidationResult googleIdResult = validateGoogleId(googleId);&#10;        if (!googleIdResult.isValid()) {&#10;            return googleIdResult;&#10;        }&#10;&#10;        // Validate Email&#10;        ValidationResult emailResult = validateEmail(email);&#10;        if (!emailResult.isValid()) {&#10;            return emailResult;&#10;        }&#10;&#10;        // Validate Display Name&#10;        ValidationResult displayNameResult = validateDisplayName(displayName);&#10;        if (!displayNameResult.isValid()) {&#10;            return displayNameResult;&#10;        }&#10;&#10;        // Validate Photo URL (optional)&#10;        ValidationResult photoUrlResult = validatePhotoUrl(photoUrl);&#10;        if (!photoUrlResult.isValid()) {&#10;            return photoUrlResult;&#10;        }&#10;&#10;        return new ValidationResult(true, &quot;All user data is valid&quot;);&#10;    }&#10;&#10;    /**&#10;     * Result class for validation&#10;     */&#10;    public static class ValidationResult {&#10;        private final boolean valid;&#10;        private final String message;&#10;&#10;        public ValidationResult(boolean valid, String message) {&#10;            this.valid = valid;&#10;            this.message = message;&#10;        }&#10;&#10;        public boolean isValid() {&#10;            return valid;&#10;        }&#10;&#10;        public String getMessage() {&#10;            return message;&#10;        }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return &quot;ValidationResult{&quot; +&#10;                    &quot;valid=&quot; + valid +&#10;                    &quot;, message='&quot; + message + '\'' +&#10;                    '}';&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/util/validation/ObservationValidation.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/util/validation/ObservationValidation.java" />
              <option name="updatedContent" value="package com.example.hikenativeapp.util.validation;&#10;&#10;/**&#10; * Utility class for validating observation data&#10; */&#10;public class ObservationValidation {&#10;&#10;    /**&#10;     * Validate observation text&#10;     * @param observationText The observation text to validate&#10;     * @return Error message if invalid, null if valid&#10;     */&#10;    public static String validateObservationText(String observationText) {&#10;        if (observationText == null || observationText.trim().isEmpty()) {&#10;            return &quot;Observation text is required&quot;;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Validate observation time&#10;     * @param observationTime The observation time to validate&#10;     * @return Error message if invalid, null if valid&#10;     */&#10;    public static String validateObservationTime(String observationTime) {&#10;        if (observationTime == null || observationTime.trim().isEmpty()) {&#10;            return &quot;Observation time is required&quot;;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Validate complete observation&#10;     * @param observationText The observation text&#10;     * @param observationTime The observation time&#10;     * @return Error message if invalid, null if valid&#10;     */&#10;    public static String validateObservation(String observationText, String observationTime) {&#10;        String textError = validateObservationText(observationText);&#10;        if (textError != null) {&#10;            return textError;&#10;        }&#10;&#10;        String timeError = validateObservationTime(observationTime);&#10;        if (timeError != null) {&#10;            return timeError;&#10;        }&#10;&#10;        return null;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>