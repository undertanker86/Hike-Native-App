<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/ui/hike_detail/ConfirmHikeActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/ui/hike_detail/ConfirmHikeActivity.java" />
              <option name="originalContent" value="package com.example.hikenativeapp.ui.hike_detail;&#10;&#10;import android.content.Intent;&#10;import android.content.SharedPreferences;&#10;import android.os.Bundle;&#10;import android.widget.Button;&#10;import android.widget.TextView;&#10;import android.widget.Toast;&#10;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.appcompat.widget.Toolbar;&#10;&#10;import com.example.hikenativeapp.R;&#10;import com.example.hikenativeapp.data.local.entity.Hike;&#10;import com.example.hikenativeapp.data.repository.HikeRepository;&#10;import com.example.hikenativeapp.ui.hike_list.HikeListActivity;&#10;import com.example.hikenativeapp.util.Constants;&#10;&#10;public class ConfirmHikeActivity extends AppCompatActivity {&#10;&#10;    private TextView tvName, tvLocation, tvDate, tvParking, tvLength, tvDifficulty;&#10;    private TextView tvDescription, tvWeatherCondition, tvEstimatedDuration;&#10;    private Button btnConfirm, btnEdit;&#10;    private Toolbar toolbar;&#10;&#10;    private HikeRepository repository;&#10;    private String name, location, date, difficulty, description, weatherCondition, estimatedDuration;&#10;    private boolean parkingAvailable;&#10;    private double length;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_confirm_hike);&#10;&#10;        initializeViews();&#10;        repository = new HikeRepository(this);&#10;        loadDataFromIntent();&#10;        displayHikeDetails();&#10;        setupClickListeners();&#10;    }&#10;&#10;    private void initializeViews() {&#10;        tvName = findViewById(R.id.tv_name);&#10;        tvLocation = findViewById(R.id.tv_location);&#10;        tvDate = findViewById(R.id.tv_date);&#10;        tvParking = findViewById(R.id.tv_parking);&#10;        tvLength = findViewById(R.id.tv_length);&#10;        tvDifficulty = findViewById(R.id.tv_difficulty);&#10;        tvDescription = findViewById(R.id.tv_description);&#10;        tvWeatherCondition = findViewById(R.id.tv_weather_condition);&#10;        tvEstimatedDuration = findViewById(R.id.tv_estimated_duration);&#10;&#10;        btnConfirm = findViewById(R.id.btn_confirm);&#10;        btnEdit = findViewById(R.id.btn_edit);&#10;        toolbar = findViewById(R.id.toolbar);&#10;&#10;        // Setup Toolbar as ActionBar&#10;        setSupportActionBar(toolbar);&#10;        if (getSupportActionBar() != null) {&#10;            getSupportActionBar().setTitle(&quot;Confirm Hike Details&quot;);&#10;            getSupportActionBar().setDisplayHomeAsUpEnabled(true);&#10;            getSupportActionBar().setDisplayShowHomeEnabled(true);&#10;        }&#10;    }&#10;&#10;    private void loadDataFromIntent() {&#10;        Intent intent = getIntent();&#10;        name = intent.getStringExtra(&quot;name&quot;);&#10;        location = intent.getStringExtra(&quot;location&quot;);&#10;        date = intent.getStringExtra(&quot;date&quot;);&#10;        parkingAvailable = intent.getBooleanExtra(&quot;parking_available&quot;, false);&#10;        length = intent.getDoubleExtra(&quot;length&quot;, 0.0);&#10;        difficulty = intent.getStringExtra(&quot;difficulty&quot;);&#10;        description = intent.getStringExtra(&quot;description&quot;);&#10;        weatherCondition = intent.getStringExtra(&quot;weather_condition&quot;);&#10;        estimatedDuration = intent.getStringExtra(&quot;estimated_duration&quot;);&#10;    }&#10;&#10;    private void displayHikeDetails() {&#10;        tvName.setText(name);&#10;        tvLocation.setText(location);&#10;        tvDate.setText(date);&#10;        tvParking.setText(parkingAvailable ? &quot;Yes&quot; : &quot;No&quot;);&#10;        tvLength.setText(String.format(&quot;%.1f km&quot;, length));&#10;        tvDifficulty.setText(difficulty);&#10;        tvDescription.setText(description.isEmpty() ? &quot;No description provided&quot; : description);&#10;        tvWeatherCondition.setText(weatherCondition);&#10;        tvEstimatedDuration.setText(estimatedDuration + &quot; hours&quot;);&#10;    }&#10;&#10;    private void setupClickListeners() {&#10;        btnConfirm.setOnClickListener(v -&gt; saveHike());&#10;        btnEdit.setOnClickListener(v -&gt; goBackToEdit());&#10;    }&#10;&#10;    private void saveHike() {&#10;        // Get current user ID&#10;        SharedPreferences prefs = getSharedPreferences(Constants.PREFS_NAME, MODE_PRIVATE);&#10;        int userId = prefs.getInt(Constants.PREF_USER_ID, -1);&#10;&#10;        if (userId == -1) {&#10;            Toast.makeText(this, &quot;Error: User not found&quot;, Toast.LENGTH_SHORT).show();&#10;            return;&#10;        }&#10;&#10;        // Create hike object&#10;        Hike hike = new Hike();&#10;        hike.setUserId(userId);&#10;        hike.setName(name);&#10;        hike.setLocation(location);&#10;        hike.setHikeDate(date);&#10;        hike.setParkingAvailable(parkingAvailable);&#10;        hike.setLength(length);&#10;        hike.setDifficulty(difficulty);&#10;        hike.setDescription(description);&#10;&#10;        // Save to database&#10;        new Thread(() -&gt; {&#10;            try {&#10;                long hikeId = repository.insertHike(hike).get();&#10;                runOnUiThread(() -&gt; {&#10;                    if (hikeId &gt; 0) {&#10;                        Toast.makeText(this, &quot;Hike saved successfully!&quot;, Toast.LENGTH_SHORT).show();&#10;                        navigateToHikeList();&#10;                    } else {&#10;                        Toast.makeText(this, &quot;Failed to save hike&quot;, Toast.LENGTH_SHORT).show();&#10;                    }&#10;                });&#10;            } catch (Exception e) {&#10;                runOnUiThread(() -&gt; {&#10;                    Toast.makeText(this, &quot;Error saving hike: &quot; + e.getMessage(), Toast.LENGTH_SHORT).show();&#10;                });&#10;            }&#10;        }).start();&#10;    }&#10;&#10;    private void goBackToEdit() {&#10;        onBackPressed();&#10;    }&#10;&#10;    private void navigateToHikeList() {&#10;        Intent intent = new Intent(this, HikeListActivity.class);&#10;        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);&#10;        startActivity(intent);&#10;        finish();&#10;    }&#10;&#10;    @Override&#10;    public boolean onSupportNavigateUp() {&#10;        onBackPressed();&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        if (repository != null) {&#10;            repository.cleanup();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.hikenativeapp.ui.confirm_hike;&#13;&#10;&#13;&#10;import android.content.Intent;&#13;&#10;import android.content.SharedPreferences;&#13;&#10;import android.os.Bundle;&#13;&#10;import android.widget.Button;&#13;&#10;import android.widget.TextView;&#13;&#10;import android.widget.Toast;&#13;&#10;&#13;&#10;import androidx.appcompat.app.AppCompatActivity;&#13;&#10;import androidx.appcompat.widget.Toolbar;&#13;&#10;&#13;&#10;import com.example.hikenativeapp.R;&#13;&#10;import com.example.hikenativeapp.data.local.entity.Hike;&#13;&#10;import com.example.hikenativeapp.data.repository.HikeRepository;&#13;&#10;import com.example.hikenativeapp.ui.hike_list.HikeListActivity;&#13;&#10;import com.example.hikenativeapp.util.Constants;&#13;&#10;&#13;&#10;public class ConfirmHikeActivity extends AppCompatActivity {&#13;&#10;&#13;&#10;    private TextView tvName, tvLocation, tvDate, tvParking, tvLength, tvDifficulty;&#13;&#10;    private TextView tvDescription, tvWeatherCondition, tvEstimatedDuration;&#13;&#10;    private Button btnConfirm, btnEdit;&#13;&#10;    private Toolbar toolbar;&#13;&#10;&#13;&#10;    private HikeRepository repository;&#13;&#10;    private String name, location, date, difficulty, description, weatherCondition, estimatedDuration;&#13;&#10;    private boolean parkingAvailable;&#13;&#10;    private double length;&#13;&#10;&#13;&#10;    @Override&#13;&#10;    protected void onCreate(Bundle savedInstanceState) {&#13;&#10;        super.onCreate(savedInstanceState);&#13;&#10;        setContentView(R.layout.activity_confirm_hike);&#13;&#10;&#13;&#10;        initializeViews();&#13;&#10;        repository = new HikeRepository(this);&#13;&#10;        loadDataFromIntent();&#13;&#10;        displayHikeDetails();&#13;&#10;        setupClickListeners();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void initializeViews() {&#13;&#10;        tvName = findViewById(R.id.tv_name);&#13;&#10;        tvLocation = findViewById(R.id.tv_location);&#13;&#10;        tvDate = findViewById(R.id.tv_date);&#13;&#10;        tvParking = findViewById(R.id.tv_parking);&#13;&#10;        tvLength = findViewById(R.id.tv_length);&#13;&#10;        tvDifficulty = findViewById(R.id.tv_difficulty);&#13;&#10;        tvDescription = findViewById(R.id.tv_description);&#13;&#10;        tvWeatherCondition = findViewById(R.id.tv_weather_condition);&#13;&#10;        tvEstimatedDuration = findViewById(R.id.tv_estimated_duration);&#13;&#10;&#13;&#10;        btnConfirm = findViewById(R.id.btn_confirm);&#13;&#10;        btnEdit = findViewById(R.id.btn_edit);&#13;&#10;        toolbar = findViewById(R.id.toolbar);&#13;&#10;&#13;&#10;        // Setup Toolbar as ActionBar&#13;&#10;        setSupportActionBar(toolbar);&#13;&#10;        if (getSupportActionBar() != null) {&#13;&#10;            getSupportActionBar().setTitle(&quot;Confirm Hike Details&quot;);&#13;&#10;            getSupportActionBar().setDisplayHomeAsUpEnabled(true);&#13;&#10;            getSupportActionBar().setDisplayShowHomeEnabled(true);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void loadDataFromIntent() {&#13;&#10;        Intent intent = getIntent();&#13;&#10;        name = intent.getStringExtra(&quot;name&quot;);&#13;&#10;        location = intent.getStringExtra(&quot;location&quot;);&#13;&#10;        date = intent.getStringExtra(&quot;date&quot;);&#13;&#10;        parkingAvailable = intent.getBooleanExtra(&quot;parking_available&quot;, false);&#13;&#10;        length = intent.getDoubleExtra(&quot;length&quot;, 0.0);&#13;&#10;        difficulty = intent.getStringExtra(&quot;difficulty&quot;);&#13;&#10;        description = intent.getStringExtra(&quot;description&quot;);&#13;&#10;        weatherCondition = intent.getStringExtra(&quot;weather_condition&quot;);&#13;&#10;        estimatedDuration = intent.getStringExtra(&quot;estimated_duration&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void displayHikeDetails() {&#13;&#10;        tvName.setText(name);&#13;&#10;        tvLocation.setText(location);&#13;&#10;        tvDate.setText(date);&#13;&#10;        tvParking.setText(parkingAvailable ? &quot;Yes&quot; : &quot;No&quot;);&#13;&#10;        tvLength.setText(String.format(&quot;%.1f km&quot;, length));&#13;&#10;        tvDifficulty.setText(difficulty);&#13;&#10;        tvDescription.setText(description.isEmpty() ? &quot;No description provided&quot; : description);&#13;&#10;        tvWeatherCondition.setText(weatherCondition);&#13;&#10;        tvEstimatedDuration.setText(estimatedDuration + &quot; hours&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void setupClickListeners() {&#13;&#10;        btnConfirm.setOnClickListener(v -&gt; saveHike());&#13;&#10;        btnEdit.setOnClickListener(v -&gt; goBackToEdit());&#13;&#10;    }&#13;&#10;&#13;&#10;    private void saveHike() {&#13;&#10;        // Get current user ID&#13;&#10;        SharedPreferences prefs = getSharedPreferences(Constants.PREFS_NAME, MODE_PRIVATE);&#13;&#10;        int userId = prefs.getInt(Constants.PREF_USER_ID, -1);&#13;&#10;&#13;&#10;        if (userId == -1) {&#13;&#10;            Toast.makeText(this, &quot;Error: User not found&quot;, Toast.LENGTH_SHORT).show();&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        // Create hike object&#13;&#10;        Hike hike = new Hike();&#13;&#10;        hike.setUserId(userId);&#13;&#10;        hike.setName(name);&#13;&#10;        hike.setLocation(location);&#13;&#10;        hike.setHikeDate(date);&#13;&#10;        hike.setParkingAvailable(parkingAvailable);&#13;&#10;        hike.setLength(length);&#13;&#10;        hike.setDifficulty(difficulty);&#13;&#10;        hike.setDescription(description);&#13;&#10;&#13;&#10;        // Save to database&#13;&#10;        new Thread(() -&gt; {&#13;&#10;            try {&#13;&#10;                long hikeId = repository.insertHike(hike).get();&#13;&#10;                runOnUiThread(() -&gt; {&#13;&#10;                    if (hikeId &gt; 0) {&#13;&#10;                        Toast.makeText(this, &quot;Hike saved successfully!&quot;, Toast.LENGTH_SHORT).show();&#13;&#10;                        navigateToHikeList();&#13;&#10;                    } else {&#13;&#10;                        Toast.makeText(this, &quot;Failed to save hike&quot;, Toast.LENGTH_SHORT).show();&#13;&#10;                    }&#13;&#10;                });&#13;&#10;            } catch (Exception e) {&#13;&#10;                runOnUiThread(() -&gt; {&#13;&#10;                    Toast.makeText(this, &quot;Error saving hike: &quot; + e.getMessage(), Toast.LENGTH_SHORT).show();&#13;&#10;                });&#13;&#10;            }&#13;&#10;        }).start();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void goBackToEdit() {&#13;&#10;        onBackPressed();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void navigateToHikeList() {&#13;&#10;        Intent intent = new Intent(this, HikeListActivity.class);&#13;&#10;        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);&#13;&#10;        startActivity(intent);&#13;&#10;        finish();&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public boolean onSupportNavigateUp() {&#13;&#10;        onBackPressed();&#13;&#10;        return true;&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    protected void onDestroy() {&#13;&#10;        super.onDestroy();&#13;&#10;        if (repository != null) {&#13;&#10;            repository.cleanup();&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/ui/hike_list/SwipeToDeleteCallback.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/ui/hike_list/SwipeToDeleteCallback.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.hikenativeapp.ui.hike_list;&#10;&#10;import android.content.Context;&#10;import android.graphics.Canvas;&#10;import android.graphics.Color;&#10;import android.graphics.drawable.ColorDrawable;&#10;import android.graphics.drawable.Drawable;&#10;import android.view.View;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.recyclerview.widget.ItemTouchHelper;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;&#10;import com.example.hikenativeapp.R;&#10;&#10;public class SwipeToDeleteCallback extends ItemTouchHelper.SimpleCallback {&#10;&#10;    private HikeAdapter adapter;&#10;    private Drawable deleteIcon;&#10;    private int intrinsicWidth;&#10;    private int intrinsicHeight;&#10;    private ColorDrawable background;&#10;    private int backgroundColor;&#10;    private OnSwipeListener onSwipeListener;&#10;&#10;    public interface OnSwipeListener {&#10;        void onSwipe(int position);&#10;    }&#10;&#10;    public SwipeToDeleteCallback(Context context, HikeAdapter adapter, OnSwipeListener listener) {&#10;        super(0, ItemTouchHelper.LEFT);&#10;        this.adapter = adapter;&#10;        this.onSwipeListener = listener;&#10;&#10;        // Initialize delete icon and background&#10;        deleteIcon = ContextCompat.getDrawable(context, R.drawable.ic_delete_white);&#10;        if (deleteIcon != null) {&#10;            intrinsicWidth = deleteIcon.getIntrinsicWidth();&#10;            intrinsicHeight = deleteIcon.getIntrinsicHeight();&#10;        }&#10;&#10;        backgroundColor = Color.parseColor(&quot;#f44336&quot;); // Red color&#10;        background = new ColorDrawable();&#10;    }&#10;&#10;    @Override&#10;    public boolean onMove(@NonNull RecyclerView recyclerView, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull RecyclerView.ViewHolder target) {&#10;        return false;&#10;    }&#10;&#10;    @Override&#10;    public void onSwiped(@NonNull RecyclerView.ViewHolder viewHolder, int direction) {&#10;        int position = viewHolder.getAdapterPosition();&#10;        if (onSwipeListener != null) {&#10;            onSwipeListener.onSwipe(position);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onChildDraw(@NonNull Canvas c, @NonNull RecyclerView recyclerView, @NonNull RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) {&#10;        super.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);&#10;&#10;        View itemView = viewHolder.itemView;&#10;        int itemHeight = itemView.getBottom() - itemView.getTop();&#10;&#10;        // Draw red background&#10;        background.setColor(backgroundColor);&#10;        background.setBounds(&#10;            itemView.getRight() + ((int) dX),&#10;            itemView.getTop(),&#10;            itemView.getRight(),&#10;            itemView.getBottom()&#10;        );&#10;        background.draw(c);&#10;&#10;        // Draw delete icon&#10;        if (deleteIcon != null) {&#10;            int deleteIconTop = itemView.getTop() + (itemHeight - intrinsicHeight) / 2;&#10;            int deleteIconMargin = (itemHeight - intrinsicHeight) / 2;&#10;            int deleteIconLeft = itemView.getRight() - deleteIconMargin - intrinsicWidth;&#10;            int deleteIconRight = itemView.getRight() - deleteIconMargin;&#10;            int deleteIconBottom = deleteIconTop + intrinsicHeight;&#10;&#10;            deleteIcon.setBounds(deleteIconLeft, deleteIconTop, deleteIconRight, deleteIconBottom);&#10;            deleteIcon.draw(c);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public float getSwipeThreshold(@NonNull RecyclerView.ViewHolder viewHolder) {&#10;        return 0.7f; // Require 70% swipe to trigger delete&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/util/UserValidator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/util/UserValidator.java" />
              <option name="updatedContent" value="package com.example.hikenativeapp.util;&#10;&#10;import android.text.TextUtils;&#10;import android.util.Patterns;&#10;&#10;/**&#10; * Validator for User-related data&#10; */&#10;public class UserValidator {&#10;&#10;    // Minimum and maximum length for display name&#10;    private static final int MIN_DISPLAY_NAME_LENGTH = 2;&#10;    private static final int MAX_DISPLAY_NAME_LENGTH = 50;&#10;&#10;    /**&#10;     * Validates display name&#10;     * @param displayName The display name to validate&#10;     * @return ValidationResult containing validity status and error message&#10;     */&#10;    public static ValidationResult validateDisplayName(String displayName) {&#10;        if (TextUtils.isEmpty(displayName)) {&#10;            return new ValidationResult(false, &quot;Display name cannot be empty&quot;);&#10;        }&#10;&#10;        String trimmed = displayName.trim();&#10;        &#10;        if (trimmed.isEmpty()) {&#10;            return new ValidationResult(false, &quot;Display name cannot be empty or contain only spaces&quot;);&#10;        }&#10;&#10;        if (trimmed.length() &lt; MIN_DISPLAY_NAME_LENGTH) {&#10;            return new ValidationResult(false, &quot;Display name must be at least &quot; + MIN_DISPLAY_NAME_LENGTH + &quot; characters&quot;);&#10;        }&#10;&#10;        if (trimmed.length() &gt; MAX_DISPLAY_NAME_LENGTH) {&#10;            return new ValidationResult(false, &quot;Display name cannot exceed &quot; + MAX_DISPLAY_NAME_LENGTH + &quot; characters&quot;);&#10;        }&#10;&#10;        // Check for invalid characters (optional - you can customize this)&#10;        if (!trimmed.matches(&quot;^[a-zA-Z0-9\\s._-]+$&quot;)) {&#10;            return new ValidationResult(false, &quot;Display name can only contain letters, numbers, spaces, and ._- characters&quot;);&#10;        }&#10;&#10;        return new ValidationResult(true, &quot;Valid display name&quot;);&#10;    }&#10;&#10;    /**&#10;     * Validates email address&#10;     * @param email The email to validate&#10;     * @return ValidationResult containing validity status and error message&#10;     */&#10;    public static ValidationResult validateEmail(String email) {&#10;        if (TextUtils.isEmpty(email)) {&#10;            return new ValidationResult(false, &quot;Email cannot be empty&quot;);&#10;        }&#10;&#10;        String trimmed = email.trim();&#10;&#10;        if (!Patterns.EMAIL_ADDRESS.matcher(trimmed).matches()) {&#10;            return new ValidationResult(false, &quot;Invalid email format&quot;);&#10;        }&#10;&#10;        return new ValidationResult(true, &quot;Valid email&quot;);&#10;    }&#10;&#10;    /**&#10;     * Validates Google ID&#10;     * @param googleId The Google ID to validate&#10;     * @return ValidationResult containing validity status and error message&#10;     */&#10;    public static ValidationResult validateGoogleId(String googleId) {&#10;        if (TextUtils.isEmpty(googleId)) {&#10;            return new ValidationResult(false, &quot;Google ID cannot be empty&quot;);&#10;        }&#10;&#10;        String trimmed = googleId.trim();&#10;&#10;        if (trimmed.isEmpty()) {&#10;            return new ValidationResult(false, &quot;Google ID cannot be empty&quot;);&#10;        }&#10;&#10;        // Google IDs are typically alphanumeric&#10;        if (!trimmed.matches(&quot;^[a-zA-Z0-9]+$&quot;)) {&#10;            return new ValidationResult(false, &quot;Invalid Google ID format&quot;);&#10;        }&#10;&#10;        return new ValidationResult(true, &quot;Valid Google ID&quot;);&#10;    }&#10;&#10;    /**&#10;     * Validates photo URL&#10;     * @param photoUrl The photo URL to validate&#10;     * @return ValidationResult containing validity status and error message&#10;     */&#10;    public static ValidationResult validatePhotoUrl(String photoUrl) {&#10;        // Photo URL is optional, so null or empty is valid&#10;        if (TextUtils.isEmpty(photoUrl)) {&#10;            return new ValidationResult(true, &quot;Photo URL is optional&quot;);&#10;        }&#10;&#10;        String trimmed = photoUrl.trim();&#10;&#10;        if (!Patterns.WEB_URL.matcher(trimmed).matches()) {&#10;            return new ValidationResult(false, &quot;Invalid photo URL format&quot;);&#10;        }&#10;&#10;        return new ValidationResult(true, &quot;Valid photo URL&quot;);&#10;    }&#10;&#10;    /**&#10;     * Validates complete user data&#10;     * @param googleId Google ID&#10;     * @param email Email address&#10;     * @param displayName Display name&#10;     * @param photoUrl Photo URL (optional)&#10;     * @return ValidationResult containing validity status and error message&#10;     */&#10;    public static ValidationResult validateUserData(String googleId, String email, &#10;                                                    String displayName, String photoUrl) {&#10;        // Validate Google ID&#10;        ValidationResult googleIdResult = validateGoogleId(googleId);&#10;        if (!googleIdResult.isValid()) {&#10;            return googleIdResult;&#10;        }&#10;&#10;        // Validate Email&#10;        ValidationResult emailResult = validateEmail(email);&#10;        if (!emailResult.isValid()) {&#10;            return emailResult;&#10;        }&#10;&#10;        // Validate Display Name&#10;        ValidationResult displayNameResult = validateDisplayName(displayName);&#10;        if (!displayNameResult.isValid()) {&#10;            return displayNameResult;&#10;        }&#10;&#10;        // Validate Photo URL (optional)&#10;        ValidationResult photoUrlResult = validatePhotoUrl(photoUrl);&#10;        if (!photoUrlResult.isValid()) {&#10;            return photoUrlResult;&#10;        }&#10;&#10;        return new ValidationResult(true, &quot;All user data is valid&quot;);&#10;    }&#10;&#10;    /**&#10;     * Result class for validation&#10;     */&#10;    public static class ValidationResult {&#10;        private final boolean valid;&#10;        private final String message;&#10;&#10;        public ValidationResult(boolean valid, String message) {&#10;            this.valid = valid;&#10;            this.message = message;&#10;        }&#10;&#10;        public boolean isValid() {&#10;            return valid;&#10;        }&#10;&#10;        public String getMessage() {&#10;            return message;&#10;        }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return &quot;ValidationResult{&quot; +&#10;                    &quot;valid=&quot; + valid +&#10;                    &quot;, message='&quot; + message + '\'' +&#10;                    '}';&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/util/validation/ObservationValidation.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/hikenativeapp/util/validation/ObservationValidation.java" />
              <option name="updatedContent" value="package com.example.hikenativeapp.util.validation;&#10;&#10;/**&#10; * Utility class for validating observation data&#10; */&#10;public class ObservationValidation {&#10;&#10;    /**&#10;     * Validate observation text&#10;     * @param observationText The observation text to validate&#10;     * @return Error message if invalid, null if valid&#10;     */&#10;    public static String validateObservationText(String observationText) {&#10;        if (observationText == null || observationText.trim().isEmpty()) {&#10;            return &quot;Observation text is required&quot;;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Validate observation time&#10;     * @param observationTime The observation time to validate&#10;     * @return Error message if invalid, null if valid&#10;     */&#10;    public static String validateObservationTime(String observationTime) {&#10;        if (observationTime == null || observationTime.trim().isEmpty()) {&#10;            return &quot;Observation time is required&quot;;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Validate complete observation&#10;     * @param observationText The observation text&#10;     * @param observationTime The observation time&#10;     * @return Error message if invalid, null if valid&#10;     */&#10;    public static String validateObservation(String observationText, String observationTime) {&#10;        String textError = validateObservationText(observationText);&#10;        if (textError != null) {&#10;            return textError;&#10;        }&#10;&#10;        String timeError = validateObservationTime(observationTime);&#10;        if (timeError != null) {&#10;            return timeError;&#10;        }&#10;&#10;        return null;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>